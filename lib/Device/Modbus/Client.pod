=pod

=head1 NAME

Device::Modbus::Client - Write Modbus clients in Perl

=head1 SYNOPSIS

A Modbus TCP client:

    #! /usr/bin/env perl

    use Device::Modbus;
    use Device::Modbus::Client;

    # These are the default parameters
    my $client = Device::Modbus::Client::TCP->new(
        host    => '127.0.0.1',
        port    => 502,
        timeout => 2
    );

    my $req = Device::Modbus->read_coils(
        address  => 20,
        quantity => 19
    );

    my $trn = $client->request_transaction($req);

    $client->send_request($trn) || die "Send error";

    my $response = $trn->response;

    print "$response\n";

A Modbus RTU client:

    #! /usr/bin/env perl

    use Device::Modbus;
    use Device::Modbus::Client::RTU;
    use Modern::Perl;

    my $client = Device::Modbus::Client::RTU->new(
        port     => '/dev/ttyUSB0',
        baudrate => 19200,
        parity   => 'none',
    );

    my $req = Device::Modbus->read_holding_registers(
        unit     => 1,
        address  => 1,
        quantity => 1
    );

    while (1) {
        my $resp = $client->send_request($req);
        say "-> $req";
        say "<- $resp";
        sleep 1;
    }

=head1 DESCRIPTION

This POD documents Device::Modbus::Client::TCP and Device::Modbus::Client::RTU, the two client modules of the L<Device::Modbus> distribution.

Modbus clients allow you to send requests to server devices (or slaves, as they are also called in the industry) and to make sense of their responses.

Once you have generated a request, the client must obtain its PDU and wrap it into an ADU prior to sending it to the server. Once the response arrives, it has to be unwrapped and parsed so that your application receives a nice response object.

To document client modules, we will start with the common functionality which basically allows for sending requests and obtaining responses.

=head1 USAGE

=head2 Methods common to both clients

=head3 send_request

This method is responsible of sending requests to a server. The input to this mehtod differs between Modbus RTU and TCP. In the RTU case, it takes a request object; in the TCP case, a transaction object. More on transactions will be discussed later.

 $client_rtu->send_request($req);
 $client_tcp->send_request($trn);

Its return value may be one of:

=over

=item * undef

The undefined value is returned in case of communication issues, both if the client was not capable of writing the request to the bus or network, or if it was not capable of reading a response. In both cases, the problem is a communication issue. 

=item * A Device::Modbus::Exception object

If the returned object is a Modbus exception, it was returned by the server. You can inspect the exception code by reading it from the object:

 say $resp->exception_code;

=item * A response object

The transaction was successful and you have your response object.

=back

=head3 Methods underlying send_request

While these methods are not required by user applications, they are provided by Device::Modbus::TCP and Device::Modbus::RTU roles and are very similar for both the RTU and TCP flavors.

=over

=item build_adu

This method receives a request object (or a response, in fact) and proudces a binary representation suitable for sending down the communication channel.

 my $adu = $client_rtu->build_adu($req);
 my $adu = $client_tcp->build_adu($trn, $req);

Again, note that the Modbus TCP variant takes a transaction object.

=item break_message

This method is the opposite of build_adu, since it takes a received binary message and breakes it into its parts:

 my ($unit, $pdu, $crc)    = $client_rtu->break_message($adu);
 my ($trn_id, $unit, $pdu) = $client_tcp->break_message($adu);

In this case, the RTU variant returns the unit number, PDU and the CRC verification value of the message. The unit represents the address of the serving device in the bus.

The TCP variant returns instead a transaction number, a unit number (which is usually not important), and the PDU.

See parse_response in L<Device::Modbus/"Parsing a PDU"> to turn a PDU into a response object.

=back

=head2 Modbus RTU client

The only other significant method for the RTU client is its constructor.

=head3 Constructor

The constructor can take the following arguments:

=over

=item * port (required)

=item * databits (default: 8)

=item * stopbits (default: 1)

=item * parity (default: even. Other valid values are 'none' and 'odd')

=item * baudrate (default: 9600)

=item * timeout (default: 2, in seconds)

=back

All these attributes have accessors of the same name.

The RTU client uses L<Device::SerialPort> and so it is does not work in Windows (but this should be easy to change).

=head2 Modbus TCP client

In contrast to the RTU client, Modbus TCP clients need the concept of transactions to work correctly. But first, let's discuss the constructor function.

=head3 Constructor

The constructor will take the following arguments:

=over

=item * host (read only, default: 127.0.0.1)

=item * port (read only, default: 502)

=item * timeout (read/write, default: 2, in seconds)

=item * max_transactions (read/write, 16 by default)

=back

All these attributes have accessors of the same name.

=head3 Transactions

The standard for Modbus TCP requires using transactions due to the fact that sockets allow for non-blocking communication. A transaction is an envelope that serves to relate a response to its request, as the protocol allows for responses arriving in a different order. Each transaction is uniquely identified. The identification number is sent along with the request and is returned by the server, thus permitting to find the request that originated a freshly arrived response.

B<IMPORTANT NOTE>

Currently, the send_request call is done in blocking mode, and we wait for the response. The mechanism to deal with non-blocking communication is incomplete and does not work. A new client would be needed for this. Transactions, however, should be usable.

=head3 Modbus TCP client methods dealing with transactions

While non-blocking clients are still not possible with this distribution, Modbus TCP clients work with transactions.

=head4 request_transaction

Receives a request object and returns a transaction object.

 # First create a request object
 my $req = Device::Modbus->read_coils(
    address  => 23,
    quantity =>  2
 );

 # and then use it to request a new transaction. You can reuse the same
 # request for many transactions
 my $trn = $client->request_transaction($req);

 # send_request will extract the request from the transaction and it
 # will use the transaction id number to build the Modbus message
 $client->send_request($trn);

=head1 GITHUB REPOSITORY

You can find the repository of this distribution in L<GitHub|https://github.com/jfraire/Device-Modbus>.

=head1 SEE ALSO

The documentation of the distribution is split among these different documents:

=over

=item L<Device::Modbus> - For basic request and response objects

=item L<Device::Modbus::Client>

=item L<Device::Modbus::Server>

=item L<Device::Modbus::Unit> - Server routing of requests

=item L<Device::Modbus::Spy>

=back

These are other implementations of Modbus in Perl:

L<Protocol::Modbus>, L<MBclient>, L<mbserverd|https://github.com/sourceperl/mbserverd>.

=head1 AUTHOR

Julio Fraire, E<lt>julio.fraire@gmail.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2015 by Julio Fraire

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.

=cut
